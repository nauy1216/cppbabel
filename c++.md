# 初始值

在 C++ 中，如果你声明一个整数变量而没有显式地提供初始值，该变量将会拥有一个不确定的初始值，这个值取决于变量的存储位置。这被称为未初始化变量。

# Student s1(12, "aaa") 和 Student s1 = new Student(12, "aaa") 的区别

## Student s1(12, "aaa")

这是在栈上创建一个 Student 对象的方式。对象在离开作用域时会自动被销毁。
使用这种方式，你无需手动管理内存，因为对象的生命周期与作用域绑定。
这种方式是更安全、更方便的，适用于大多数情况。

### 错误的用法

在函数内部创建对象，并且返回这个对象的指针。

```c++
utils_struct::Student* getNewObjPointer(utils_struct::Student old)
{
    old.age = 13;
    // 这里的old对象是在函数作用域从参数复制过来的
    // 函数执行完之后会销毁这个对象
    // 所以这里不能返回这个临时对象的指针
    return &old;
};
```

## Student\* s1 = new Student(12, "aaa");

这是在堆上动态分配一个 Student 对象的方式。对象的生命周期不受作用域限制，需要手动释放内存。
使用这种方式，你需要负责手动释放内存，否则可能导致内存泄漏。
动态分配的对象不会在离开作用域时自动销毁，你需要使用 delete 关键字来显式释放内存。

## 智能指针

栈上创建对象更容易管理，而堆上创建对象需要更多的责任和小心。在现代 C++ 中，推荐使用栈上的对象，除非有明确的理由需要使用动态分配的对象。如果需要动态分配，建议使用智能指针（如 std::unique_ptr 或 std::shared_ptr）来更安全地管理内存。


# 函数返回指针的两种方式
1. 接受一个指针，并且返回这个指针
2. 使用new在堆上创建对象


# 指针和引用的区别
## 指针（Pointers）
1. 指针是一个变量，其值为另一个变量的地址。
2. 声明指针时，需要指定指针的数据类型。
3. 使用 * 运算符来访问指针指向的变量的值。
4. 指针可以具有空值，表示不指向任何有效的地址。
```c++
int* ptr = nullptr; // 空指针
```
5. 指针本身的值（即存储的地址）可以改变，可以指向不同的变量。

## 引用（References）
1. 引用是一个**变量的别名**，它引用（绑定到）另一个变量。
2. 在声明引用时，无需指定引用的数据类型。
3. 无需 * 运算符，引用直接使用变量名来访问其引用的变量。
4. 不可为 nullptr，**引用必须在初始化时绑定到一个变量，且不能在其生命周期内更改绑定。**
5. 不可变，引用一旦绑定到一个变量，就不能再绑定到其他变量。

# 函数不能返回在当前栈中创建的对象的引用和指针，因为函数执行完之后对象就已经销毁了。

